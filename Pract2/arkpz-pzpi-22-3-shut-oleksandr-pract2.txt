Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії
    
    
    

    
ЗВІТ
з практичного заняття №2
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»
    
    
    
    
    
    
    Виконав ст. гр. ПЗПІ-22-3
    Шуть Олександр Вікторович

    Перевірив
    ст. викладач кафедри ПІ Сокорчук Ігор Петрович
    
    
    
    
    
    
Харків 2024
1 МЕТА РОБОТИ

     Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчити аналізувати та рефакторити код для покращення його якості.

2 ВСТУП

    Рефакторинг — це процес покращення структури коду без зміни його функціональності, що особливо важливо для таких мов, як TypeScript. Завдяки статичній типізації TypeScript надає розробникам потужний інструментарій для виявлення та запобігання помилкам ще на етапі написання коду. Рефакторинг у свою чергу допомагає зробити цей код більш читабельним, зрозумілим і легким у підтримці. Головна мета рефакторингу полягає в усуненні дублювання, зменшенні складності та покращенні архітектури програми. У TypeScript рефакторинг може включати оптимізацію типів, зменшення залежностей між модулями та приведення коду до сучасних стандартів. Завдяки цьому код стає не тільки більш зрозумілим для інших розробників, а й значно надійнішим, що полегшує його підтримку та масштабування у майбутньому.

3 ХІД РОБОТИ

	Посилання на відео з поясненням методів рефакторинга коду наведено у додатку А.

	3.1 Перший метод

	Код, до якого буде застасовано перший метод рефакторинга, наведено у додатку Б на рядках 1-33.
	3.1.1 Опис проблеми, яку вирішує даний метод
     
     Велика функція часто містить багато логічних блоків, що виконують різні завдання одночасно. Це ускладнює розуміння коду, тестування, а також збільшує ймовірність помилок під час змін. Підтримка такого коду стає складною: додаються нові функції, що призводить до збільшення часу на ознайомлення для нових розробників і підвищує ризик порушення існуючої логіки. Розбиття функцій дозволяє кожній виконувати одну чітку задачу, підвищує зрозумілість, спрощує повторне використання та тестування.

	3.1.2 Опис коду до застосування методу

     Функція processOrder, наведена у додатку Б на рядках 1-15, є дуже великою та виконує кілька різних задач, що робить її важкою для розуміння та підтримки. Вона обробляє замовлення, перевіряючи, чи є в ньому ідентифікатор та елементи. Потім розраховує загальну суму замовлення, перебираючи всі елементи, та виводить результат у консоль. Цей код містить три різні логічні блоки: валідацію даних, обчислення загальної суми та виведення результату. Через таку суміш різних завдань стає складно перевірити кожен з блоків окремо, а також розширювати функціональність без ризику порушення інших частин. Крім того, складно протестувати окремі частини логіки, що значно ускладнює тестування та налагодження. Такі функції важко змінювати без негативного впливу на інші частини коду, що підвищує ймовірність помилок при модифікаціях.

	3.1.3 Опис коду після застосування методу 

Після застосування методу розбиття функцій на менші частини, які наведені у додатку А на рядках 16-33, функція processOrder стала набагато простішою та чіткішою. Кожна частина логіки тепер знаходиться в окремій функції, що дозволяє значно покращити підтримку та тестування. Всі завдання, які раніше виконувала одна велика функція, тепер реалізовані в трьох окремих функціях. Перевірка валідності замовлення винесена в функцію validateOrder, що дозволяє легко тестувати її окремо. Розрахунок суми замовлення здійснюється через окрему функцію calculateTotal, що спрощує обчислення та забезпечує можливість перевірки результатів кожної операції. Функція processOrder тепер виконує лише основну логіку, викликаючи допоміжні функції для валідації та обчислення суми. Це дозволяє зменшити складність основної функції та підвищити її зручність для подальших змін або розширень, оскільки кожна частина коду стала ізольованою і легко зрозумілою.

	3.1.4 Пояснення переваг використаного методу

	Розбиття великої функції на менші дозволяє ізолювати логіку валідації та розрахунків у своїх окремих функціях. Це робить кожну частину більш зрозумілою і фокусується на конкретних задачах, що зменшує складність. Завдяки цьому, код стає легшим для читання та зміни, оскільки кожна функція має свою чітку задачу, і змінювати одну частину не впливає на інші. Крім того, таке розбиття значно полегшує тестування окремих частин програми. Тепер можна перевіряти валідацію і розрахунки окремо, без необхідності тестувати всю функціональність в одному блоці коду.

	3.2 Другий метод

     Код, до якого буде застасовано другий метод рефакторинга, наведено у додатку В на рядках 1-39.




     3.2.1 Опис проблеми, яку вирішує даний метод

     Проблема коду, що містить велику кількість умовних операторів, полягає в його складності для читання та підтримки. Такі конструкції, як if/else чи switch, ускладнюють розуміння логіки, особливо якщо вони охоплюють безліч сценаріїв. Додавання нових умов або зміна існуючих вимагають змін у багатьох місцях, що значно збільшує ризик помилок. Такий код стає негнучким, і кожна нова умова ускладнює структуру програми, роблячи її важкою для тестування та розширення. Використання поліморфізму дозволяє уникнути цих проблем, забезпечуючи чітку структуру, яка спрощує внесення змін і тестування, та надає можливість динамічно змінювати поведінку програми без модифікації базового коду.

	3.2.2 Опис коду до застосування методу

     Функція calculateDiscount, наведена у додатку В на рядках 1-12, демонструє проблему використання багатьох умовних операторів для визначення розміру знижки. У цьому коді обчислення знижки залежить від типу замовлення (regular, premium, vip), і логіка реалізована через каскад умов if/else. Такий підхід ускладнює читання та розуміння коду, особливо якщо кількість типів замовлень збільшиться. 
     Додавання нового типу замовлення вимагає модифікації основної функції, що підвищує ризик внесення помилок у вже існуючу логіку. Крім того, структура коду не є гнучкою, що ускладнює його розширення та підтримку.
     
     3.2.3 Опис коду після застосування методу 

     У результаті застосування методу заміни умовних операторів на поліморфізм, як продемонстровано у додатку В на рядках 14–39, логіка визначення знижки була розподілена між окремими класами, які реалізують спільний інтерфейс DiscountStrategy. Кожен клас (RegularDiscount, PremiumDiscount, VipDiscount) відповідає за обчислення знижки для відповідного типу замовлення.
     Замість каскаду умов у функції calculateDiscount, тепер використовується динамічний вибір стратегії знижки. Основна функція викликає метод calculate обраної стратегії, що дозволяє додавати нові типи знижок без змін у базовій логіці. 
     Цей підхід робить код більш структурованим, полегшує його розширення, а також зменшує ризик помилок, оскільки додавання нової логіки не впливає на існуючі класи.

     3.2.4 Пояснення переваг використаного методу

     Після застосування методу заміни умовних операторів на поліморфізм код набув значних переваг. Він став модульним і розширюваним, оскільки кожна стратегія знижки тепер реалізується у вигляді окремого класу. Це дозволяє легко додавати нові стратегії без внесення змін до основного алгоритму, що знижує ризик виникнення помилок і підвищує підтримуваність коду. Основна структура залишається незмінною, а реалізація нових функцій відповідає принципу відкритості/закритості, роблячи систему більш гнучкою до змін. Крім того, тестування стало простішим, адже кожну стратегію можна перевірити окремо, забезпечуючи надійність і коректність роботи кожного компонента.

     3.3 Третій метод

     Код, до якого буде застасовано другий метод рефакторинга, наведено у додатку Г на рядках 1-14.
     
     3.3.1 Опис проблеми, яку вирішує даний метод

     Метод усунення побічних ефектів спрямований на вирішення проблем, які виникають через функції, що змінюють глобальні змінні або зовнішній стан. Такі функції роблять поведінку програми непередбачуваною, ускладнюючи процес розуміння того, як і коли змінюється стан. Це особливо критично у багатопотокових сценаріях, де висока ймовірність конфліктів і труднощів із синхронізацією даних. Залежність від зовнішніх змін створює бар’єри для ефективного тестування, оскільки результати виконання можуть змінюватися залежно від стану, що існував раніше. Усуваючи побічні ефекти, код стає більш передбачуваним і краще масштабується, що полегшує тестування й підвищує стабільність системи. Крім того, створення чистих функцій, які не залежать від зовнішнього стану, робить код прозорішим і легшим для підтримки.
     
     3.3.2 Опис коду до застосування методу

     До застосування методу усунення побічних ефектів функція addToTotal, як продемонстровано у додатку Г на рядках 1–7, змінює глобальну змінну total. Такий підхід створює низку проблем: залежність від зовнішнього стану робить функцію непрогнозованою, оскільки її поведінка залежить від поточного значення змінної total. У разі виклику функції з різних місць програми важко передбачити кінцевий результат, що ускладнює тестування та налагодження. Зміна глобального стану також підвищує ризик конфліктів у багатопотокових сценаріях, де одночасний доступ до змінної може призвести до помилок. Код такого типу погано масштабується і стає дедалі важчим для підтримки у великих системах.



     3.3.3 Опис коду після застосування методу

     	Після застосування методу усунення побічних ефектів код став більш прогнозованим і чистим, як продемонстровано у додатку Г на рядках 9–14. Функція calculateNewTotal не змінює глобальний стан, а працює лише з переданими аргументами. Це дозволяє ізолювати логіку обчислення і виключає залежність від зовнішніх змінних. Тепер функція повертає нове значення, яке можна використовувати за потреби, не змінюючи вихідний стан. Такий підхід сприяє створенню більш читабельного, масштабованого та легкого для тестування коду. Використовуючи чисті функції, програма стає стійкішою до помилок, особливо у складних сценаріях із паралельними обчисленнями.

     3.3.4 Пояснення переваг використаного методу

     Усунення побічних ефектів у коді має кілька суттєвих переваг. По-перше, функція після рефакторингу працює виключно з вхідними параметрами, не змінюючи глобальний стан, що значно покращує її прогнозованість і дозволяє уникнути небажаних змін у програмі. По-друге, такий підхід полегшує тестування, оскільки результат функції залежить лише від переданих аргументів, що спрощує створення тестових сценаріїв і перевірку коректності роботи. По-третє, код стає передбачуваним і менш схильним до помилок, особливо в багатопотокових середовищах, де зміни спільного стану можуть спричинити складні для діагностики конфлікти. Це забезпечує стабільність і надійність роботи програмного забезпечення.
     
     
ВИСНОВКИ

     У результаті застосування методів рефакторингу коду на TypeScript було досягнуто значного покращення якості програмного забезпечення. Використання підходів, таких як розбиття великих функцій, заміна умовних операторів на поліморфізм та усунення побічних ефектів, дозволяє зробити код більш модульним, зрозумілим і гнучким. Це сприяє покращенню підтримуваності, оскільки нові функціональності можна додавати без зміни основної логіки програми. Крім того, зменшення залежності від глобального стану і виключення побічних ефектів робить код більш передбачуваним і стійким до помилок. Реалізація цих методів полегшує тестування та налагодження, що в свою чергу підвищує ефективність розробки і зменшує ймовірність виникнення помилок у процесі підтримки програмних систем.

















СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

     1. Мартін Ф. (2018). Refactoring: Improving the Design of Existing Code. (дата використання: 27.11.2024).

ДОДАТОК А
Відео-посилання на YouTube відео

https://youtu.be/NzaKlj-ivvU

ДОДАТОК Б
Код до та після застосування методу «Розбиття великих функцій»

01 // Код до рефакторингу:
02 function processOrder(order: any) {
03   // Валідація
04   if (!order.id || !order.items.length) {
05       throw new Error("Invalid order");
06   }
07   // Розрахунок ціни
08   let total = 0;
09   order.items.forEach((item: any) => {
10       total += item.price * item.quantity;
11   });
12   // Створення чека
13   console.log(`Order #${order.id} total: ${total}`);
14   return total;
15 }
16
17 // Код після рефакторингу:
18 function validateOrder(order: any): void {
19   if (!order.id || !order.items.length) {
20       throw new Error("Invalid order");
21   }
22 }
23
24 function calculateTotal(order: any): number {
25   return order.items.reduce((total: number, item: any) => total + item.price * item.quantity, 0);
26 }
27
28 function processOrder(order: any) {
29   validateOrder(order);
30   const total = calculateTotal(order);
31   console.log(`Order #${order.id} total: ${total}`);
32   return total;
33 }

ДОДАТОК В
Код до та після застосування методу «Заміна умовних операторів на поліморфізм»

01 // Код до рефакторингу:
02 function calculateDiscount(order: any) {
03   if (order.type === "regular") {
04       return order.amount * 0.05;
05   } else if (order.type === "premium") {
06       return order.amount * 0.1;
07   } else if (order.type === "vip") {
08       return order.amount * 0.2;
09   } else {
10       return 0;
11   }
12 }
13
14 // Код після рефакторингу:
15 interface DiscountStrategy {
16   calculate(order: any): number;
17 }
18
19 class RegularDiscount implements DiscountStrategy {
20   calculate(order: any): number {
21       return order.amount * 0.05;
22   }
23 }
24
25 class PremiumDiscount implements DiscountStrategy {
26   calculate(order: any): number {
27       return order.amount * 0.1;
28   }
29 }
30
31 class VipDiscount implements DiscountStrategy {
32   calculate(order: any): number {
33       return order.amount * 0.2;
34   }
35 }
36
37 function calculateDiscount(order: any, strategy: DiscountStrategy): number {
38   return strategy.calculate(order);
39 }

ДОДАТОК Г
Код до та після застосування методу «Усунення побічних ефектів»

01 // Код до рефакторингу:
02 let total = 0;
03
04 function addToTotal(amount: number) {
05   total += amount;
06   return total;
07 }
08
09 // Код після рефакторингу:
10 function calculateNewTotal(currentTotal: number, amount: number): number {
11   return currentTotal + amount;
12 }
13
14 const total = calculateNewTotal(0, 50);

ДОДАТОК Д 
Скриншоти презентації


Рисунок Д.1 – Титульний лист


Рисунок Д.2 – Зміст


Рисунок Д.3 – Вступ. Поняття рефакторинг


Рисунок Д.4 – Метод 1. Розбиття великих функцій


Рисунок Д.5 – Опис коду до застосування методу 1


Рисунок Д.6 – Опис коду після застосування методу 1

Рисунок Д.7 – Пояснення переваг методу 1


Рисунок Д.8 – Метод 2. Заміна умовних операторів на поліморфізм


Рисунок Д.9 – Опис коду до застосування методу 2


Рисунок Д.10 – Опис коду після застосування методу 2


Рисунок Д.11 – Пояснення переваг методу 2


Рисунок Д.12 – Метод 3. Усунення побічних ефектів


Рисунок Д.13 – Опис коду до застосування методу 3


Рисунок Д.14 – Опис коду після застосування методу 3


Рисунок Д.15 – Пояснення переваг методу 3


Рисунок Д.16 – Інструменти для рефакторингу

Рисунок Д.17 – Висновки


Рисунок Д.18 – Список використаних джерел



    2
    
    
