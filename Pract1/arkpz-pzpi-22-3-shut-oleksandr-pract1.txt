Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії
    
    
    

    
ЗВІТ
з практичного заняття №1
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду»
    
    
    
    
    
    
    Виконав ст. гр. ПЗПІ-22-3
    Шуть Олександр Вікторович

    Перевірив
    ст. викладач кафедри ПІ Сокорчук Ігор Петрович
    
    
    
    
    
    
Харків 2024
МЕТА РОБОТИ

     Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчити аналізувати та рефакторити код для покращення його якості.

ВСТУП

     TypeScript – це надбудова над JavaScript, яка суттєво полегшує життя розробникам, додаючи можливості статичної типізації. В умовах, коли вимоги до якості та надійності коду постійно зростають, TypeScript стає незамінним інструментом для команд, що працюють над великими та масштабованими проєктами. Завдяки його можливостям для визначення типів, а також підтримці об’єктно-орієнтованих принципів, TypeScript допомагає уникати багатьох помилок ще на етапі розробки. Правила та рекомендації оформлення коду TypeScript є важливою частиною цього процесу, оскільки вони забезпечують зручність підтримки, зрозумілість і високу читабельність коду, що дозволяє розробникам продуктивно співпрацювати та підтримувати якість проєкту на високому рівні.

ХІД РОБОТИ
РЕКОМЕНДАЦІЇ ОФОРМЛЕННЯ КОДУ

     Посилання на відео з демонстраціями порад оформлення коду мовою TypeScript наведено в додатку А.
     Порада: використовуйте prettier та eslint.
     Мова TypeScript немає чітких правил щодо форматування. Зазвичай правила форматування залежать від компанії чи навіть команди, яка пише код. Для налаштування правил форматування використовують prettier та eslint пакети та конфіги. Ці пакети автоматично форматують код відкритого файлу за допомогою шорт катів, які були зроблені під час налаштування пакетів. З допомогою цих пакетів код виглядає в єдиному стилі, що покращує навігацію по ньому та і в цілому його розуміння, оскільки стиль форматування не змінюється з кожним рядком.
     Недотримання рекомендацій може значно ускладнити розуміння та навігацію по коду.
     Приклад гарного та поганого форматування наведено в додатку Б.
     Порада: використовуйте осмислені назви змінних.
     Назви змінних повинні відображати їхню суть та мету в коді. Чітко підібрані імена полегшують розуміння функціоналу та логіки коду, як для вас, так і для інших розробників. Уникайте коротких або абстрактних назв, таких як x, data, або temp, якщо вони не є очевидними. Замість цього надавайте змінним такі назви, які описують їх зміст або роль, наприклад, userProfile, orderTotal або isAuthenticated. Це підвищує читабельність і значно полегшує навігацію та підтримку коду.
     Якщо не дотримуватись цієї рекомендації, код стане важким для розуміння та супроводу, оскільки іншим розробникам буде складно визначити, що саме представляє кожна змінна. Це може призвести до зростання кількості помилок, витрат часу на з'ясування функціоналу змінних, а також ускладнити налагодження та внесення змін у майбутньому.
     Приклад гарного та поганого виикористання назв змінних наведено в додатку В.
     Порада: використовуйте легко вимовні назви змінних.
     Назви змінних, які легко вимовити, полегшують їхнє обговорення в команді, що є особливо важливим під час код-рев'ю, зустрічей чи обговорень. Коли назви легко вимовляються, це знижує ризик непорозумінь та сприяє більш ефективній комунікації між розробниками. Уникайте назв, які важко вимовити чи запам'ятати, оскільки це може уповільнити процес роботи над проєктом.
     Якщо не дотримуватись цієї рекомендації, це може ускладнити співпрацю з іншими членами команди, призводити до непорозумінь та витрат часу на уточнення назв змінних, що в кінцевому підсумку уповільнює роботу і підвищує ризик помилок.
     Приклад гарного та поганого виикористання легко вимовних змін наведено в додатку Г.
     Порада: використовуйте camelCase для змінних та функцій.
     Використання camelCase для найменування змінних і функцій є стандартною практикою в TypeScript, що підвищує узгодженість та читабельність коду. camelCase допомагає візуально відокремлювати слова у складених назвах, що робить код легшим для сприйняття та навігації. 
     Якщо не дотримуватись цієї рекомендації, можуть виникнути проблеми з узгодженістю в коді, особливо при роботі в команді. Використання різних стилів для змінних і функцій збільшує ризик помилок та плутанини, а також ускладнює читання коду та його підтримку.
     Приклад гарного та поганого виикористання camelCase для змінних та функцій наведено в додатку Ґ.
     Порада: не використовуйте негативні назви для булевих змінних.
     Булеві змінні повинні мати назви, які позитивно описують їхнє значення. Використання позитивних назв, таких як isVisible, isAuthenticated, hasAccess, полегшує розуміння коду та допомагає уникнути двозначностей. Негативні назви, як-от isNotVisible або notAuthenticated, можуть заплутати, особливо при використанні з операторами заперечення, оскільки !isNotVisible може стати важчим для інтерпретації.
     Недотримання цієї рекомендації може призвести до складнощів у розумінні логіки коду, особливо під час читання або налагодження. Це підвищує ризик появи логічних помилок, особливо у великих проєктах, де такі назви можуть стати причиною некоректної поведінки програми.
     Приклад гарного та поганого виикористання негативних назв для булевих змінних наведено в додатку Е.
     Порада: використовуйте типізування за допомогою ключових слів type та interface.
     Типізування в TypeScript за допомогою type та interface підвищує структурованість і надійність коду, роблячи його зрозумілішим і легшим для підтримки. interface використовується для визначення формату об'єктів, що полегшує масштабування і підтримує концепцію об'єктно-орієнтованого програмування. type дозволяє створювати гнучкі типи, як-от об’єднання або перетини, що спрощує роботу з різними варіаціями типів.
     Ігнорування типізування може призвести до помилок, які виявляються лише під час виконання, а не на етапі написання коду. Це ускладнює налагодження та збільшує ризик введення логічних помилок, оскільки структура даних залишається непередбачуваною, а код менш захищений від некоректного використання даних.
     Приклад гарного та поганого виикористання типізації за допомого ключових слів type та interface наведено в додатку Є.
     Порада: використовуйте наслідування від інтерфейсів або типів.
     Наслідування від інтерфейсів або типів у TypeScript дозволяє створювати гнучкі й масштабовані структури, що знижує дублювання коду та спрощує підтримку. Наприклад, можна визначити базовий інтерфейс User з основними полями й розширити його в інтерфейсах Admin або Customer, додаючи специфічні властивості для кожного типу користувача. Це сприяє повторному використанню та узгодженості даних у всьому проєкті.
     Недотримання цієї рекомендації може призвести до надмірного дублювання коду та ускладнити підтримку, оскільки змінювати структуру доведеться в багатьох місцях. Це збільшує ризик помилок і знижує читабельність, особливо у великих проєктах, де відсутність наслідування ускладнює розуміння ієрархії та структури даних.
     Приклад гарного та поганого виикористання наслідування від інтерфейсів або типів наведено в додатку Ж.
     Порада: використовуйте модифікатори доступу.
     Модифікатори доступу в TypeScript (public, private, protected) допомагають чітко контролювати доступ до властивостей і методів класів, покращуючи інкапсуляцію й захищаючи внутрішні дані об’єктів. Наприклад, використання private для внутрішніх полів і методів обмежує їхнє використання лише в межах класу, зменшуючи ризик некоректного доступу або зміни даних ззовні. protected дозволяє доступ до елементів у межах класу і його наслідувань, що є корисним для побудови спадкової ієрархії.
     Якщо не використовувати модифікатори доступу, це може призвести до порушення принципу інкапсуляції, коли внутрішні дані можуть бути ненавмисно змінені ззовні. Це підвищує ризик непередбачуваних помилок, знижує стабільність коду і ускладнює його налагодження та підтримку.
     Приклад гарного та поганого виикористання модифікаторів доступу наведено в додатку З.
     Порада: використовуйте константи та enum`и.
     Використання констант та enum-ів у TypeScript допомагає підвищити читабельність та стабільність коду, оскільки вони дозволяють уникнути "магічних чисел" та рядків у коді. Константи (const) застосовуються для значень, що не змінюються протягом виконання програми, а enum-и забезпечують зрозумілі назви для груп пов'язаних значень, таких як статуси або типи ролей користувачів. Це дозволяє легко змінювати або оновлювати значення в одному місці без ризику неузгодженостей у коді.
     Недотримання цієї рекомендації може призвести до виникнення "магічних значень" у коді, що ускладнює його розуміння та підвищує ризик помилок при внесенні змін. Невикористання enum-ів також може зменшити узгодженість коду, оскільки значення, які логічно пов’язані, залишаються без структури, що ускладнює підтримку та читання коду.
     Приклад гарного та поганого виикористання констант та enum`ів наведено в додатку И.
     Порада: уникайте неявних “any”.
     Неявний тип any в TypeScript позбавляє код переваг типізації, оскільки дозволяє змінній мати будь-який тип, що знижує здатність компілятора виявляти помилки на етапі написання коду. Замість цього варто завжди явно вказувати типи або використовувати типи, які можуть бути автоматично виведені TypeScript.
     Ігнорування цієї поради може призвести до неочікуваних помилок під час виконання коду, оскільки відсутність чітких типів створює ризик некоректного використання даних. Це також ускладнює підтримку коду, оскільки його читабельність знижується, а гарантії типобезпеки слабшають.
     Приклад гарного та поганого уникання неявних any наведено в додатку І.
     Порада: запобігайте зайвій типізації та перевіркам.
     Надмірна типізація й перевірки в TypeScript можуть призвести до громіздкого та менш гнучкого коду. TypeScript має потужну систему виведення типів, що може автоматично визначати типи в багатьох випадках, тому часто немає потреби у зайвому уточненні типів, наприклад, при присвоєнні значень змінним або в аргументах функцій. Оптимальна типізація забезпечує баланс між безпекою й зручністю, не перевантажуючи код зайвими деталями.
     Якщо не уникати зайвої типізації, код стає складнішим для підтримки й читання, а також важчим для внесення змін. Зайві перевірки й типи збільшують час написання коду та можуть знизити його продуктивність, створюючи дублювання й перевантаження типових конструкцій.
     Приклад гарного та поганого використання зайвої типізації та перевірок наведено в додатку Ї.
     
     
ВИСНОВКИ

     Отже, дотримання правил оформлення коду в TypeScript – це важливий крок для створення якісного, структурованого і надійного програмного забезпечення. Завдяки строгій типізації, використанню інтерфейсів і дженериків, TypeScript допомагає запобігати помилкам, покращує передбачуваність поведінки програми та спрощує підтримку коду. Дотримання стандартів найменування, форматування і рефакторингу підвищує зручність читання та розуміння коду для всієї команди, сприяючи продуктивній роботі над проєктом. У результаті використання TypeScript дозволяє створювати надійний та легко масштабований код, що відповідає сучасним вимогам до розробки програмного забезпечення.


















СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

     1. Typescript coding style guide. GitHub . URL: link-to-repo (дата використання: 11.11.2024).

ДОДАТОК А
Відео-посилання на YouTube відео

https://youtu.be/gkx8Rzl2YEI
ДОДАТОК Б
Приклад гарного та поганого форматування

1: // Поганий приклад
2: import { PostDto } from '~types/post/post.dto'
3: import {  ErrorException   } from "~types/error/error.type"
4:
5:
6: export const  CreatePost =()=> {
7:   const navigate = useNavigate()
8:   const content  = useRef<HTMLSpanElement>(null )
9:   const [ createPost  ] = useCreatePostMutation()
10:   const user = useAppSelector(state => state.userSlice.user)
11:
12: // Гарний приклад
13:
14: import { PostDto } from '~types/post/post.dto'
15: import { ErrorException } from '~types/error/error.type'
16:
17:
18: export const CreatePost = () => {
19:   const navigate = useNavigate()
20:   const content = useRef<HTMLSpanElement>(null)
21:   const [createPost] = useCreatePostMutation()
22:   const user = useAppSelector(state => state.userSlice.user)
ДОДАТОК В
Приклад гарного та поганого виикористання назв змінних

1 // Поганий приклад
2 function isBetween(a1: number, a2: number, a3: number): boolean {
3   return a2 <= a1 && a1 <= a3;
4 }
5
6 // Гарний приклад
7 function isBetween(value: number, left: number, right: number): boolean {
8  return left <= value && value <= right;
9 }
ДОДАТОК Г
Приклад гарного та поганого виикористання легко вимовних змін

1 // Поганий приклад
2 class Subs {
3   public ccId: number;
4   public billingAddrId: number;
5   public shippingAddrId: number;
6 }
7
8 // Гарний приклад
9 class Subscription {
10   public creditCardId: number;
11   public billingAddressId: number;
12   public shippingAddressId: number;
13 }
ДОДАТОК Ґ
Приклад гарного та поганого виикористання camelCase для змінних та функцій

1 // Поганий приклад
2 var FooVar;
3 function BarFunc() { }
4
5 // Гарний приклад
6 var fooVar;
7 function barFunc() { }

ДОДАТОК Е
Приклад гарного та поганого виикористання негативних назв для булевих змінних

1 // Поганий приклад
2 const isNotEnabled = true;
3
4 // Гарний приклад
5 const isEnabled = false; 
ДОДАТОК Є
Приклад гарного та поганого виикористання типізації за допомого ключових слів type та interface

1 // Поганий приклад
2 const user: any = { name: "John", age: 25 };
3
4 // Гарний приклад
5 interface User {
6   name: string;
7   age: number;
8 }
9
10 const user: User = { name: "John", age: 25 };2 const isNotEnabled = true;
ДОДАТОК Ж
Приклад гарного та поганого виикористання наслідування від інтерфейсів або типів

1 // Поганий приклад
2 interface Animal {
3   name: string;
4  }
5
6 interface Dog {
7   name: string;
8   breed: string;
9 }
10
11 // Гарний приклад
12 interface Animal {
13   name: string;
14  }
15
16 interface Dog extends Animal {
17   breed: string;
18 }
ДОДАТОК З
Приклад гарного та поганого виикористання модифікаторів доступу

1 // Поганий приклад
2 class User {
3   name: string;
4   age: number;
5   password: string;
6 }
7
8 const user = new User();
9 user.password = "12345"
10
11 // Гарний приклад
12 class User {
13   name: string;
14   age: number;
15   private password: string;
16
17   constructor(password: string) {
18     this.password = password
19   }
20
21   changePassword(newPassword: string) {
22     this.password = newPassword
23   }
24 }
ДОДАТОК И
Приклад гарного та поганого виикористання констант та enum`ів

1 // Поганий приклад
2 const STATUS_NEW = "new";
3 const STATUS_IN_PROGRESS = "in progress";
4 const STATUS_DONE = "done";
5
6 // Гарний приклад
7 enum Status {
8   New = "new",
9   InProgress = "in progress",
10  Done = "done"
11 }
12
13 const currentStatus: Status = Status.New;
ДОДАТОК І
Приклад гарного та поганого уникання неявних any

1 // Поганий приклад
2 function calculate(value) {
3   return value * 2;
4 }
5
6 // Гарний приклад
7 function calculate(value: number): number {
8   return value * 2;
9 }
ДОДАТОК Й
Скриншоти презентації


Рисунок Й.1 – Титульний лист


Рисунок Й.2 – Короткий огляд особливостей мови TypeScript


Рисунок Й.3 – Стильові рекомендації мови TypeScript. Порада щодо форматування


Рисунок Й.4 – Приклад поганого та гарного форматування


Рисунок Й.5 – Поради щодо найменування змінних, функцій та класів


Рисунок Й.6 – Приклад поганого та гарного найменування змінних функцій та класів

Рисунок Й.7 – Приклад поганого та гарного найменування змінних функцій та класів. Частина 2


Рисунок Й.8 – Принципи рефакторингу мови TypeScript


Рисунок Й.9 – Приклад поганої та гарної типізації за допомогою ключових слів type та interface


Рисунок Й.10 – Приклад поганого та гарного наслідування від інтерфейсів або типів


Рисунок Й.11 – Приклад поганого та гарного використання модифікаторів доступу


Рисунок Й.12 – Приклад поганого та гарного використання констант та enum`ів


Рисунок Й.13 – Приклад уникання неявних any


Рисунок Й.14 – Оптимізація продуктивності


Рисунок Й.15 – Список використаних джерел


Рисунок Й.16 – Висновки